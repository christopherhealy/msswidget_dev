<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MSS Widget</title>

  <!-- Default theme; will be switched after we load CONFIG.theme -->
  <link id="themeCss" rel="stylesheet" href="themes/mss-widget-apple.css"/>

  <style>
    body {
      margin: 0;
      padding: 16px;
      background: #f3f4f6;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      justify-content: center;
    }
    .mss-card {
      width: 100%;
      max-width: 720px;
    }
    .mss-file { display:none; }
    .mss-filebadge { font-size:.75rem; color:#6b7280; margin-top:4px; text-align:center; }
    .mss-line {
      height:3px; border-radius:999px;
      background:linear-gradient(90deg,#1d4ed8,#e5e7eb);
      width:0%; transition:width .2s ease; margin-top:6px;
    }
    .mss-logstatus { font-size:.75rem; margin-top:4px; text-align:center; }
    .mss-logstatus.ok { color:#16a34a; }
    .mss-logstatus.err { color:#dc2626; }
  </style>
</head>
<body>
  <div class="mss-card">
    <div class="mss-head">
      <img id="logo" class="mss-logo" alt="Brand logo"/>
      <div class="mss-brandwrap">
        <div id="brand" class="mss-brand">MySpeakingScore Widget</div>
        <div id="powered" class="mss-muted">Loading configâ€¦</div>
      </div>
    </div>

    <div class="mss-body">
      <div id="counter" class="mss-counter"></div>
      <div id="question" class="mss-q"></div>

      <div class="mss-nav">
        <button id="prevBtn" class="mss-pill">Previous</button>
        <button id="nextBtn" class="mss-pill">Next</button>
      </div>

      <div class="mss-actions">
        <div class="mss-toolbar">
          <button id="recBtn"  class="mss-btn primary">Record your response</button>
          <button id="stopBtn" class="mss-btn" disabled>Stop</button>

          <label for="fileInput" class="mss-btn mss-filelabel">Choose an audio file</label>
          <input id="fileInput" class="mss-file" type="file" accept="audio/*"/>

          <button id="clearFileBtn" class="mss-btn" style="display:none;">Clear file</button>
        </div>

        <div class="mss-recbar">
          <span id="recDot" class="mss-dot"></span>
          <span id="recState" class="mss-muted">Not recording</span>
          <span id="timer" class="mss-timer mss-muted"></span>
        </div>

        <div id="fileBadge" class="mss-filebadge"></div>

        <div id="playerWrap" style="display:none; margin-top:8px; text-align:center;">
          <audio id="player" controls preload="metadata" style="width:100%;"></audio>
          <div class="mss-muted" id="lengthHint" style="margin-top:4px;"></div>
        </div>

        <div class="mss-row" style="margin-top:10px;">
          <button id="submitBtn" class="mss-btn" disabled>Submit for scoring</button>
        </div>

        <div class="mss-resultswrap">
          <div id="progressText" class="mss-muted"></div>
          <div id="progressLine" class="mss-line"></div>
          <div id="logStatus" class="mss-logstatus"></div>
        </div>
      </div>

      <div id="status" class="mss-status"></div>
    </div>
  </div>

<script>
/* ------------------------------------------------------------------
   SERVICE / ENV
------------------------------------------------------------------ */
const SERVICE_BASE = window.location.hostname.includes('localhost')
  ? 'http://localhost:3000'
  : 'https://msswidget-dev.onrender.com';

const MODE = SERVICE_BASE.includes('localhost') ? 'LOCAL DEV' : 'RENDER PROD';
console.log(`ðŸ§© MSS Widget running in ${MODE} (SERVICE_BASE=${SERVICE_BASE})`);

/* ------------------------------------------------------------------
   STATE
------------------------------------------------------------------ */
const $ = (id) => document.getElementById(id);
let FORM = null;
let CONFIG = null;
let IMAGE = null;
let idx = 0;

let chunks = [];
let mediaRecorder = null;
let recording = false;
let blob = null;
let uploadedFile = null;
let audioUrl = null;
let timerId = null;

let progressId = null;
let progressStart = 0;

/* ------------------------------------------------------------------
   HELPERS
------------------------------------------------------------------ */
function setStatus(msg, ok = true) {
  const el = $("status");
  el.textContent = msg;
  el.className = "mss-status " + (ok ? "ok" : "warn");
}

function getLogoFrom(image) {
  if (!image) return "";
  for (const k of ["logoDataUrl","dataUrl","logo","src","url","path"]) {
    if (image[k]) return String(image[k]);
  }
  return "";
}

function mmss(ms) {
  const s = Math.floor(ms / 1000);
  const m = Math.floor(s / 60);
  const r = s % 60;
  return `${String(m).padStart(2,"0")}:${String(r).padStart(2,"0")}`;
}

function getDurationBounds() {
  const minS = Number(CONFIG?.audioMinSeconds ?? 30);
  const maxS = Number(CONFIG?.audioMaxSeconds ?? 61);
  return { minS, maxS };
}

/* ------------------------------------------------------------------
   LOAD CONFIG / FORM / IMAGE (Render-first, local fallback)
------------------------------------------------------------------ */
async function loadAll() {
  try {
    const [cfgRes, formRes, imgRes] = await Promise.all([
      fetch(`${SERVICE_BASE}/config/widget?ts=${Date.now()}`, { cache: "no-store" }),
      fetch(`${SERVICE_BASE}/config/forms?ts=${Date.now()}`,  { cache: "no-store" }),
      fetch(`${SERVICE_BASE}/config/images?ts=${Date.now()}`, { cache: "no-store" }),
    ]);

    if (cfgRes.ok) CONFIG = await cfgRes.json();
    if (formRes.ok) FORM  = await formRes.json();
    if (imgRes.ok)  IMAGE = await imgRes.json();
  } catch (e) {
    console.warn("Remote config fetch failed, falling back to local /src files", e);
  }

  // Local fallback if anything missing
  if (!FORM) {
    try {
      const r = await fetch("src/form.json?ts="+Date.now(), { cache:"no-store" });
      if (r.ok) FORM = await r.json();
    } catch {}
  }
  if (!CONFIG) {
    try {
      const r = await fetch("src/config.json?ts="+Date.now(), { cache:"no-store" });
      if (r.ok) CONFIG = await r.json();
    } catch {}
  }
  if (!IMAGE) {
    try {
      const r = await fetch("src/image.json?ts="+Date.now(), { cache:"no-store" });
      if (r.ok) IMAGE = await r.json();
    } catch {}
  }

  // Safe defaults
  FORM = FORM || { headline:"Practice TOEFL Speaking Test", survey:[] };
  CONFIG = CONFIG || {
    editable:{},
    theme:"apple",
    api:{ enabled:true, baseUrl:"https://app.myspeakingscore.com", key:"", secret:"" },
    logger:{ enabled:false, url:"" },
    audioMinSeconds:30,
    audioMaxSeconds:61
  };
  IMAGE = IMAGE || {};

  applyThemeFromConfig(CONFIG);
  applyBranding(FORM, IMAGE, CONFIG);
  renderQuestion();
  resetRecording("Not recording");

  setStatus("Ready âœ…", true);
}

function applyThemeFromConfig(cfg) {
  const t = (cfg.theme || "apple").toLowerCase();
  const link = $("themeCss");
  let file = "themes/mss-widget-apple.css";
  if (t === "default") file = "themes/mss-widget-default.css";
  if (t === "pink")    file = "themes/mss-widget-pink.css";
  link.setAttribute("href", file);
}

function applyBranding(form, image, cfg) {
  $("brand").textContent = form.headline || "MySpeakingScore Widget";

  const showPowered = !(cfg.editable && cfg.editable.poweredByLabel === false);
  const poweredText = form.poweredByLabel || "Powered by MSS Vox";
  $("powered").textContent = showPowered ? poweredText : "";
  if (!showPowered) $("powered").style.display = "none";

  const logo = getLogoFrom(image);
  if (logo) $("logo").src = logo;
}

/* ------------------------------------------------------------------
   QUESTIONS
------------------------------------------------------------------ */
function renderQuestion() {
  const list = Array.isArray(FORM.survey) ? FORM.survey : [];
  if (!list.length) {
    $("counter").textContent = "";
    $("question").textContent = "(No questions configured)";
    return;
  }
  if (idx < 0) idx = 0;
  if (idx >= list.length) idx = list.length - 1;

  $("counter").textContent = `Question ${idx + 1} of ${list.length}`;
  $("question").textContent = list[idx];
}

/* ------------------------------------------------------------------
   RECORDING
------------------------------------------------------------------ */
function clearTimer() {
  if (timerId) {
    clearInterval(timerId);
    timerId = null;
  }
  $("timer").textContent = "";
}

function resetRecording(msg = "Not recording") {
  recording = false;
  chunks = [];
  blob = null;

  if (audioUrl) {
    try { URL.revokeObjectURL(audioUrl); } catch {}
    audioUrl = null;
  }

  $("recBtn").disabled = !!uploadedFile;
  $("stopBtn").disabled = true;
  $("submitBtn").disabled = !(uploadedFile || blob);

  $("recDot").classList.remove("on");
  $("recState").textContent = msg;
  $("playerWrap").style.display = (uploadedFile || blob) ? "block" : "none";

  clearTimer();
  $("lengthHint").textContent = "";
}

async function startRecording() {
  if (uploadedFile) return;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    mediaRecorder = new MediaRecorder(stream, { mimeType:"audio/webm" });
    chunks = [];

    mediaRecorder.ondataavailable = (e) => {
      if (e.data && e.data.size) chunks.push(e.data);
    };
    mediaRecorder.onstop = finalizeRecording;

    mediaRecorder.start();
    recording = true;

    $("recBtn").disabled = true;
    $("stopBtn").disabled = false;
    $("recDot").classList.add("on");
    $("recState").textContent = "Recordingâ€¦";
    $("playerWrap").style.display = "none";

    const started = Date.now();
    timerId = setInterval(() => {
      const secs = Math.floor((Date.now() - started) / 1000);
      $("timer").textContent = secs + "s";
    }, 250);

    setStatus("Recording started", true);
  } catch (e) {
    console.warn(e);
    setStatus("Mic error / permission denied", false);
  }
}

function stopRecording() {
  if (!mediaRecorder || !recording) return;
  recording = false;
  try { mediaRecorder.stop(); } catch {}
  $("stopBtn").disabled = true;
  $("recDot").classList.remove("on");
  $("recState").textContent = "Processingâ€¦";
  clearTimer();
}

function finalizeRecording() {
  blob = new Blob(chunks, { type:"audio/webm" });
  audioUrl = URL.createObjectURL(blob);
  $("player").src = audioUrl;
  $("playerWrap").style.display = "block";
  $("recState").textContent = "Ready to play or submit";
  $("recBtn").disabled = false;
  $("submitBtn").disabled = false;
  setStatus("Recording ready", true);

  $("player").onloadedmetadata = () => {
    const d = $("player").duration || 0;
    const { minS, maxS } = getDurationBounds();
    const mins = String(Math.floor(minS/60)).padStart(2,'0');
    const secs = String(minS%60).padStart(2,'0');
    const maxm = String(Math.floor(maxS/60)).padStart(2,'0');
    const maxs = String(maxS%60).padStart(2,'0');
    $("lengthHint").textContent = `Length: ${mmss(d*1000)} (must be ${mins}:${secs}â€“${maxm}:${maxs})`;
  };
}

/* ------------------------------------------------------------------
   FILE UPLOAD
------------------------------------------------------------------ */
$("fileInput").addEventListener("change", (e) => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;

  uploadedFile = f;
  $("fileBadge").textContent = `Selected: ${f.name} (${(f.size/1024/1024).toFixed(2)} MB)`;
  $("clearFileBtn").style.display = "inline-block";
  $("recBtn").disabled = true;
  $("stopBtn").disabled = true;

  if (audioUrl) {
    try { URL.revokeObjectURL(audioUrl); } catch {}
  }
  audioUrl = URL.createObjectURL(f);
  $("player").src = audioUrl;
  $("playerWrap").style.display = "block";
  $("submitBtn").disabled = false;

  $("player").onloadedmetadata = () => {
    const d = $("player").duration || 0;
    const { minS, maxS } = getDurationBounds();
    const mins = String(Math.floor(minS/60)).padStart(2,'0');
    const secs = String(minS%60).padStart(2,'0');
    const maxm = String(Math.floor(maxS/60)).padStart(2,'0');
    const maxs = String(maxS%60).padStart(2,'0');
    $("lengthHint").textContent = `Length: ${mmss(d*1000)} (must be ${mins}:${secs}â€“${maxm}:${maxs})`;
  };
});

$("clearFileBtn").addEventListener("click", () => {
  uploadedFile = null;
  $("fileInput").value = "";
  $("fileBadge").textContent = "";
  $("clearFileBtn").style.display = "none";
  resetRecording("File cleared â€” ready to record");
});

/* ------------------------------------------------------------------
   PROGRESS BAR
------------------------------------------------------------------ */
function startProgress(label = "Submitting") {
  progressStart = performance.now();
  $("progressText").textContent = label + "â€¦ 0.00s";
  $("progressLine").style.width = "10%";
  progressId = setInterval(() => {
    const t = ((performance.now() - progressStart) / 1000).toFixed(2);
    $("progressText").textContent = `${label}â€¦ ${t}s`;
    const w = Math.min(95, 10 + (performance.now() - progressStart) / 40);
    $("progressLine").style.width = w + "%";
  }, 120);
}
function stopProgress(msg = "Done") {
  if (progressId) {
    clearInterval(progressId);
    progressId = null;
  }
  $("progressText").textContent = msg;
  $("progressLine").style.width = "100%";
  setTimeout(() => {
    $("progressLine").style.width = "0%";
    $("progressText").textContent = "";
  }, 600);
}

/* ------------------------------------------------------------------
   SUBMIT TO MSS
------------------------------------------------------------------ */
function getAudioToSend() {
  if (uploadedFile) return uploadedFile;
  if (blob) return blob;
  return null;
}

// Quick access check
async function checkAccess(baseUrl, key) {
  try {
    const url = baseUrl.replace(/\/+$/,'') + "/api/check-access";
    const r = await fetch(url, { headers:{ "API-KEY": key, "Accept":"application/json" } });
    const body = await r.json().catch(()=> ({}));
    return { ok:r.ok, status:r.status, body };
  } catch (e) {
    return { ok:false, status:0, body:{ error:String(e) } };
  }
}

// Very light WEBMâ†’WAV conversion for non-WAV uploads (best effort)
async function maybeTranscodeToWav(inputBlob) {
  if (!inputBlob) return null;
  if (/^audio\/wav/i.test(inputBlob.type)) return inputBlob;

  const arr = await inputBlob.arrayBuffer();
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const abuf = await ctx.decodeAudioData(arr);
  ctx.close();

  const chs = abuf.numberOfChannels;
  const rate = abuf.sampleRate;
  const len = abuf.length;
  const bytesPerSample = 2;
  const blockAlign = chs * bytesPerSample;
  const dataBytes = len * blockAlign;
  const buf = new ArrayBuffer(44 + dataBytes);
  const view = new DataView(buf);

  function writeStr(offset, str) {
    for (let i=0;i<str.length;i++) {
      view.setUint8(offset+i, str.charCodeAt(i));
    }
  }

  writeStr(0, "RIFF");
  view.setUint32(4, 36+dataBytes, true);
  writeStr(8, "WAVE");
  writeStr(12,"fmt ");
  view.setUint32(16,16,true);
  view.setUint16(20,1,true);
  view.setUint16(22,chs,true);
  view.setUint32(24,rate,true);
  view.setUint32(28,rate*blockAlign,true);
  view.setUint16(32,blockAlign,true);
  view.setUint16(34,16,true);
  writeStr(36,"data");
  view.setUint32(40,dataBytes,true);

  const chData = Array.from({length:chs},(_,i)=>abuf.getChannelData(i));
  let offset = 44;
  for (let i=0;i<len;i++) {
    for (let c=0;c<chs;c++) {
      let s = Math.max(-1, Math.min(1, chData[c][i]));
      view.setInt16(offset, s<0 ? s*0x8000 : s*0x7FFF, true);
      offset += 2;
    }
  }
  return new Blob([buf], { type:"audio/wav" });
}

async function submitRecording() {
  const audio = getAudioToSend();
  if (!audio) {
    setStatus("No audio to submit", false);
    return;
  }

  const base   = (CONFIG?.api?.baseUrl || "").trim();
  const key    = (CONFIG?.api?.key || "").trim();
  const secret = (CONFIG?.api?.secret || "").trim();

  if (!base || !key || !secret) {
    setStatus("Missing MSS API baseUrl / key / secret in config.json", false);
    return;
  }

  // duration validation
  const player = $("player");
  const dur = player?.duration || 0;
  const { minS, maxS } = getDurationBounds();
  if (!Number.isNaN(dur) && dur > 0 && (dur < minS || dur > maxS)) {
    setStatus(`Audio must be between ${minS} and ${maxS} seconds. Please try again.`, false);
    return;
  }

  startProgress("Submitting");
  $("submitBtn").disabled = true;
  setStatus("Preparing audioâ€¦");

  let wavBlob;
  try {
    wavBlob = await maybeTranscodeToWav(audio);
  } catch (e) {
    console.warn("Transcode failed", e);
    stopProgress("Failed");
    setStatus("Could not prepare audio", false);
    $("submitBtn").disabled = false;
    return;
  }

  const access = await checkAccess(base, key);
  if (!access.ok) {
    stopProgress("Failed");
    setStatus(`Access check failed (${access.status})`, false);
    $("submitBtn").disabled = false;
    return;
  }

  setStatus("Submitting to MSSâ€¦");

  try {
    const endpoint = base.replace(/\/+$/,'') + "/api/codebot/vox";
    const fd = new FormData();
    fd.append("file", wavBlob, uploadedFile ? uploadedFile.name : "answer.wav");

    const t0 = performance.now();
    const res = await fetch(endpoint, {
      method: "POST",
      headers: {
        "API-KEY": key,
        "X-API-SECRET": secret,
        "Accept": "application/json"
      },
      body: fd
    });
    const elapsed = (performance.now() - t0)/1000;
    const json = await res.json().catch(() => ({}));

    if (res.ok) {
      stopProgress("Done");
      setStatus("Submitted âœ…", true);
      $("submitBtn").disabled = false;

      // open gauge dashboard
      openDashboard(json);

      // log to CSV service
      await logToRender(json, {
        fileName: uploadedFile ? uploadedFile.name : "answer.wav",
        lengthSec: Math.round(dur || 0),
        submitTime: Number(elapsed.toFixed(2)),
        question: Array.isArray(FORM?.survey) ? (FORM.survey[idx] || "") : ""
      });
    } else {
      stopProgress("Failed");
      setStatus(`Submit failed (${res.status})`, false);
      $("submitBtn").disabled = false;
    }
  } catch (e) {
    console.warn(e);
    stopProgress("Failed");
    setStatus("Network / CORS error", false);
    $("submitBtn").disabled = false;
  }
}

/* ------------------------------------------------------------------
   LOGGING TO RENDER (CSV)
------------------------------------------------------------------ */
async function logToRender(resultBody, meta) {
  const enabled = Boolean(CONFIG?.logger?.enabled);
  const urlCfg  = CONFIG?.logger?.url;
  const url = urlCfg || `${SERVICE_BASE}/log/submission`;

  if (!enabled || !url) {
    $("logStatus").textContent = "";
    $("logStatus").className = "mss-logstatus";
    return;
  }

  const ts = new Date().toISOString();

  const toefl = resultBody?.elsa_results?.toefl_score ?? resultBody?.toefl_score ?? "";
  const ielts = resultBody?.elsa_results?.ielts_score ?? resultBody?.ielts_score ?? "";
  const pte   = resultBody?.elsa_results?.pte_score   ?? resultBody?.pte_score   ?? "";
  const cefr  = (resultBody?.elsa_results?.cefr_level || resultBody?.cefr_level || "").toString().toUpperCase();
  const transcript = (resultBody?.transcript || "").toString().trim();

  let wpm = "";
  try {
    if (transcript) {
      const words = transcript.split(/\s+/).filter(Boolean).length;
      const minutes = Math.max(0.01, (meta.lengthSec || 0) / 60);
      wpm = Math.round(words / minutes);
    }
  } catch {}

  const payload = {
    timestamp: ts,
    ip: "",
    userId: "",
    fileName: meta.fileName || "",
    lengthSec: meta.lengthSec || "",
    submitTime: meta.submitTime || "",
    toefl, ielts, pte, cefr,
    question: meta.question || "",
    transcript,
    wpm
  };

  const el = $("logStatus");
  el.textContent = "Loggingâ€¦";
  el.className = "mss-logstatus";

  try {
    const r = await fetch(url, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    const j = await r.json().catch(()=> ({}));
    if (r.ok && j?.ok) {
      el.textContent = "Logged âœ“";
      el.className = "mss-logstatus ok";
    } else {
      el.textContent = "Log failed";
      el.className = "mss-logstatus err";
    }
  } catch (e) {
    console.warn("Logger error", e);
    el.textContent = "Log error";
    el.className = "mss-logstatus err";
  }
}

/* ------------------------------------------------------------------
   DASHBOARD MODAL (gauge-style Dashboard.html)
------------------------------------------------------------------ */
function mapResultsForDashboard(body) {
  const b = body || {};
  const er = b.elsa_results || {};

  const score =
    b.score ??
    b.overall_score ??
    b.overall ??
    er.score ??
    null;

  const CI50min = b.CI50min ?? b.ci50_min ?? null;
  const CI50max = b.CI50max ?? b.ci50_max ?? null;
  const CI95min = b.CI95min ?? b.ci95_min ?? null;
  const CI95max = b.CI95max ?? b.ci95_max ?? null;

  const transcript =
    b.transcript_html ??
    b.transcriptHTML ??
    b.transcript ??
    er.transcript_html ??
    er.transcript ??
    "";

  const cefr =
    er.cefr_level ??
    b.cefr_level ??
    b.cefr ??
    "";

  const ielts =
    er.ielts_score ??
    b.ielts_score ??
    b.ielts ??
    null;

  const toefl =
    er.toefl_score ??
    b.toefl_score ??
    b.toefl ??
    null;

  const pte =
    er.pte_score ??
    b.pte_score ??
    b.pte ??
    null;

  return {
    score,
    CI50min,
    CI50max,
    CI95min,
    CI95max,
    transcript,
    elsa_results: {
      cefr_level: cefr,
      ielts_score: ielts,
      toefl_score: toefl,
      pte_score: pte
    }
  };
}

function openDashboard(resultBody) {
  const payload = mapResultsForDashboard(resultBody);

  let overlay = document.getElementById("mssDashOverlay");
  let frame   = document.getElementById("mssDashFrame");

  if (!overlay) {
    overlay = document.createElement("div");
    overlay.id = "mssDashOverlay";
    overlay.style.cssText =
      "position:fixed;inset:0;z-index:9999;background:rgba(15,23,42,.55);" +
      "display:flex;align-items:center;justify-content:center;padding:10px;";

    frame = document.createElement("iframe");
    frame.id = "mssDashFrame";
    frame.title = "MSS Score Results";
    frame.src = "Dashboard.html";
    frame.style.cssText =
      "width:min(1080px,100%);height:min(720px,100%);border:0;" +
      "background:white;border-radius:18px;box-shadow:0 25px 60px rgba(15,23,42,.55);";

    overlay.appendChild(frame);
    document.body.appendChild(overlay);

    // Click outside to close
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        try { overlay.remove(); } catch {}
      }
    });

    // Allow Dashboard.html to signal close if it wants
    window.addEventListener("message", (e) => {
      try {
        if (e.data && e.data.type === "dashboard-close") {
          overlay.remove();
        }
      } catch {}
    });

    frame.addEventListener("load", () => {
      try {
        frame.contentWindow?.postMessage(
          { type:"mss-results", payload },
          "*"
        );
      } catch (e) {
        console.warn("postMessage to dashboard failed on load", e);
      }
    });
  } else {
    try {
      frame.contentWindow?.postMessage(
        { type:"mss-results", payload },
        "*"
      );
    } catch (e) {
      console.warn("postMessage to existing dashboard failed", e);
    }
  }
}

/* ------------------------------------------------------------------
   WIRE UI
------------------------------------------------------------------ */
window.addEventListener("DOMContentLoaded", async () => {
  await loadAll();

  $("prevBtn").addEventListener("click", () => {
    idx--; renderQuestion(); resetRecording("Not recording");
  });
  $("nextBtn").addEventListener("click", () => {
    idx++; renderQuestion(); resetRecording("Not recording");
  });

  $("recBtn").addEventListener("click", startRecording);
  $("stopBtn").addEventListener("click", stopRecording);
  $("submitBtn").addEventListener("click", submitRecording);
});
</script>
</body>
</html>